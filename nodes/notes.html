Singlethread is for synchronous operation
Gaming , video  editing , rendering this are CPU intensive work 
New thread means new resources ,new RAM should be allocated

#traditional resources
A server can handle multiple request
server has thread pool , it creates new thread whenever request comes to the server
New thread means new resources ,new different process, new RAM should be allocated , 
almost separated from the server ,and after fetching data from the server will provide to the request
when new request comes it creates new thread , then data is being fetched and send it to the request


Node server
when R1 i.e request1 or R2i.e request2 comes to node server it creates new threads and send to Linux
based server. where code is in C++..Node .js server creates new thread and after creating new thread it
spawn C++ thread, C++ fetch the data and send the response to the request made
Linux based OS threads are very fast , node js can access directly Os threads so fast and scalable..

Nodejs never blocks itself , therefore it is single threaded aand non-blocking

Event loop listen to new jobs coming to it , it checks how many jobs have come to it and listen to
what are the jobs have been completed and thats why it creates a complete loop.. ansychronous job
are done by the help of event loop

Synchronous jobs are completed by single thred

thread is a child of a process. One process can create multiple threads ,which  works asynchronously 
and it create response and send the reponse to the request

If you need to do (a+b) operation it also need to generate a process, one process can 
spawn multiple threads
One process can access multiple request and can spawn multiple threads ...

Single thread is a kind of resource where only synchronous work occurs..,metaphorically .., its a kind of
single road

when a request R1 comes to nodejs server , single thread does the synchronous work i.e 
the CPU intensive work, and for the asynchronous work it creates the C++ thread,basically the OS thread
C++ thread of R1 do the async work i.e the I/O work, and let say it take 1.2 secs
R1 is holding the single thread for about very few seconds 0.00001sec 
In the meantime the sigle thread gets unblocked.. so it is being blocked only for  0.00001sec 
and R2 also comes single thread does the synchronous work it the  creates C++ thread for aysnc  work
In the meantime the Response of R1 request will come after 1.2 secs , at the clients end loading 
will show at the client page , the loading time includes internet latency , 
fetching data server for I/O work take a bit of as it is involved multiple operations..

single thread does the CPU intense work that works very fast and 
single thread can handle several request, here in Nodejs request comes , does the sync work,where it uses
minimal resources unlike the traditional servers where multiple threads need to be made
and if the single thread seems new C++ thread should be made , it makes ,and C++ thread is very light 
,as it work with OS , it is fast also

Non-blocking is lik not blocking the the main thread i.e the main thread , for the desired work i.e asyn work
it is spawning the new C++ thread  

Nodejs Server make the C++ thread out of the box which which I dont have to write 

OS code is written in C++..Every harware systems read and write in Assembly language ..
And just above the assesmbly , C++ layer is being put on , which makes the OS work fast ,
C++ is fast pograming language 


//^ this is caret which means while running npm update, it will update this package version ,
if ^ caret is not there , the package wont update , and it will remain in that specified version ,
it wont update, even if running the npm update 

npm install -g <package name> it will install the package globally , it will install inside the node
of this computer 

All the packages written inside the dependencies will be installed inside the node modules

Dev dependencies are those packages which I dont want to install inside the production system environment

"dependencies" : Packages required by your application in production. 
"devDependencies" : Packages that are only needed for local development and testing.

how to install dev-dependecy 
npm i -D <package_name>

in terminal type node then process.env ,so node followed by process.env
after that a lot environment variables willbe visible on the screen, this are called environment variables
, with the help of these environment variables , OS tries to configure multiple  things of  node like 
path.log

process.env.my_age=43 follwed by process.env ..my_age variable will make an entry to the environment list and
come at the bottom 
this entry i.e my_age can also be accessed by OS 
process is the variable of OS, with the help of this process OS can access environment variables 

npm init will generate package.json by asking several question like name, version,
description,author,lisence,git etc
npm init -y wont ask anything and will generate the package.json


<h1>important</h1>
arrow function needs to decalred and defined i.e needs to initialized
before it is called or being passed 
b()
// ^ReferenceError: Cannot access 'b' before initialization
const b = () => {
  console.log(PORT);
};
U sign beside the folder name means it is inside the git eco system,
after entering the files inside the gitignore U sign wont be there , so when you do git status,
those files which are mentioned inside the gitignore wont show up 

we do keep the secret data inside the .env file ,
.env file is very sensitive towards spaces and tabs 
secret data like api key 

wherever the server runs , it is the responsibility of the process of that OS to provide the PORT data
const PORT = process.env.PORT; // getting the data PORT by using process.env.PORT by the procees of the OS
to configure the .env file we need to install dotenv library
with the help of dotenv library we can add the variables inside the .env files to the process environment 
variables

.env is the file where we store secret data , and we dont want that to be send to github


<h1>Router</h1>

localhost:8000/api/auth/signup.. /api for main router /auth for authrouter, /signup is the end point 
mainRouter is the parent, its has two child routers i.e authrouter and postRouter and then it has its individual endpoints
i.e /login ,signup and /post /all



localhost:8000/api/post/all.. /api is for main router /auth for authrouter, and /all is for the API end points

// by default it will go to index.js as index.js is entry point of any folder in javascript
const mainRouter = require("./routes/");

const router = require("express").Router();
console.log(router); //function
[Function: router] {
  params: {},
  _params: [],
  caseSensitive: undefined,
  mergeParams: undefined,
  strict: undefined,
  stack: []
}

// router is also a kind of middleware
// when the url hit the /post routes API end point, postRouter will be triggered
// control comes to the app.js  first and checks the routes API and its end points ,
// then it gets redirected to desired router,
// postRouter wil work when the API end points is /post
// moving to routes folder
// app.use("/post", postRouter);
// when the API end points includes /auth, it will redirect to authRouter , then authRouter will decide
//  upon API end points which router it should call
// control comes to the app.js  first and checks the routes API end points ,
// then it gets redirected to desired router
// moving to routes folder
// app.use("/auth", authRouter);
// so the routes will go like /api/post/all or /api/auth/login or signup
// so entry point is app.js request will go to mainRouter as /api,then request will go to
// postrouter i.e post module then  endpoint i.e all
// /api/post/all
// so entry point is app.js  requestwill go to mainRouter as /api ,then request will go to authrouter
//  as /auth i.e  auth module then login,signup endpoints as end point /login or signup
// /api/auth/login
// main router is the parent router where request will go first then the request goes to
// authRouter and postRouter which is the child router
app.use("/api", mainRouter);
// OR
app.use("/", mainRouter);



<h1>.ENV file</h1>
/ wherever the server runs , it is the responsibility of the process of that OS to provide the PORT data
// OS has the object named as process which is grabbing the environment variable PORT
const PORT = process.env.PORT; // getting the data PORT by using process.env.PORT by the procees of the OS

// configuring the file ,the variable inside the.env file has become environment variables
dotEnvName.config({ path: "./.env" });
